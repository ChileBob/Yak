#!/usr/bin/perl

# yak-web
#
# Websocket echo server for use with yak-zec, yak-yec, yak-yak, yak-client and friends.
#
# MIT License (ChileBob)
#
# Zcash : zs1a7qnkg8hr74ujj08jhjcdfs7s62yathqlyn5vd2e8ww96ln28m3t2jkxun5fp7hxjntcg8ccuvs
# Ycash : ys17fsj64ydl93net807xr00ujz2lnrf22cjf4430vvz69vpaat8t3hrdjmkvj7thrw4fdaz7l0pns

my $config = {						# default configuration
	port =>  8834,
	tick =>  5,
	debug => 5
};

require "./packet.pm";

# TODO: cache transparent txns, confirmations & announcements, allows clients to catch up
# TODO: spam prevention, rate limit client sending
# TODO: spam prevention, disconnect & block
# TODO: spam prevention, authenication for connecting nodes
# TODO: whale watching, on tick events send the largest transparent output seen in the last hour

###################################################################################################################################################
#
# CHANGING STUFF BELOW THIS LINE IS A BAD IDEA
#
###################################################################################################################################################

use utf8;
use Net::WebSocket::Server;				# websocket server
use Convert::Base64;					# base64 encode/decode
use Digest::SHA qw(sha256);				# sha hashing for network packets


require './common.pm';					# common subs

my %transport;						# transport encoding for each connection (BINARY, BASE64)
my %clientkey;						# client keys
my @tracker;						# array of hashed packets, prevents duplicates

$SIG{INT} = \&server_shutdown;				# graceful shutdown (not implemented)

Net::WebSocket::Server->new(				# setup websocket server

	listen => $config->{'port'},			# network port number we listen to

	tick_period => $config->{'tick'},		# seconds between timestamp/tick events (5 seconds or less)

	on_tick => sub {				##################################################################################################

		my ($serv, $conn) = @_;

		common::debug($config->{'debug'}, "tick..");			# heartbeat
		my $msg = pack("H*", '0501');

		foreach ($serv->connections) {					# send to all connected clients
			writeClient($_, $msg);				
		}
	},

	on_connect => sub {				##################################################################################################

		my ($serv, $conn) = @_;

		$conn->on(
													##################################
			binary => sub {									# received binary (ciphertext) : data

				my ($conn, $msg) = @_;

				if (packetTrack($msg) == 1) {						# check packet not a duplicate
					foreach ($serv->connections) {					# send to all connected clients
						writeClient($_, $msg);				
					}
				}
			},
													##################################
			utf8 => sub {									# received text 

				my ($conn, $msg) = @_;	

				if ( $msg =~ m/^BINARY/ || $msg =~ m/^BASE64/) {			# client subscription
					
					($transport->{$conn}, $clientkey->{$conn}) = split(':', $msg);	# store connection type and client key
					$conn->send_utf8("HELLO\n");					# say hi to the client
					common::debug(0, "Connect : $clientkey->{$conn}");
				}

				else {

					my $msg_binary = $msg;						# assume client sent binary data

					if ($transport->{$conn} eq 'BASE64') {				# convert from base64 if required

						$msg_binary = decode_base64($msg);				
					}								
	
					if (packetTrack($msg_binary) == 1) {				# check packet not a duplicate

						foreach ($serv->connections) {				# broadcast to all clients
							writeClient($_, $msg_binary);
						}
					}
				}
			},
		);
	},
)->start;



#############################################################################################################################################################################
#
# shutdown server
#
sub server_shutdown {

# TODO: broadcast a shutdown message to all clients
	
	common::debug(0, "Bye!");

	exit; 		
}


#############################################################################################################################################################################
#
# send data to websocket client using their transport encoding
#
sub writeClient {

	my ($conn, $binary) = @_;

	if ($transport->{$conn} eq 'BINARY') {				# android clients, most efficient method
		$conn->send_binary($binary);
		common::debug($config->{'debug'}, "writeClient() : BINARY");
	}

	elsif ($transport->{$conn} eq 'BASE64') {			# perl clients as their binary method is borked
		$conn->send_utf8(encode_base64($binary));
		common::debug($config->{'debug'}, "writeClient() : BASE64");
	}
}


#############################################################################################################################################################################
#
# check if a packet has already been broadcast, otherwise add its hash to the tracker
#
sub packetTrack {

	my ($packet) = @_;			# binary packet data 

	my $hash = sha256($packet);		# hash the packet

	if (!grep $_ eq $hash, @tracker) {	# not found, clear to send
		push @tracker, $hash;

		if (scalar @tracker > 100) {	# dont let the tracker get too big
			shift @tracker;
		}
		return(1);
	}
}

