#!/usr/bin/perl
#
# yak-yak : websocket server 
#
# MIT License (ChileBob)
#
# Zcash : zs1a7qnkg8hr74ujj08jhjcdfs7s62yathqlyn5vd2e8ww96ln28m3t2jkxun5fp7hxjntcg8ccuvs
# Ycash : ys17fsj64ydl93net807xr00ujz2lnrf22cjf4430vvz69vpaat8t3hrdjmkvj7thrw4fdaz7l0pns

my $config = {											# default configuration
	auth  => 'changethispassword',								# password to avoid rate limiter
	key   => 'changethiskey',								# encryption key, nodes must encrypt with this key before sending here
	limit => 20,										# max number of posts per tick interval 
	port  =>  8834,										# listening port number
	tick  =>  10,										# tick interval (seconds)
	tracker => 100										# packet tracker (hash of packets))
};

# #################################################################################################################################
#
# CHANGING ANYTHING BELOW THIS LINE IS A BAD IDEA
#
# #################################################################################################################################

use utf8;
use Data::Dumper;										# debugging

use Net::WebSocket::Server;									# websocket server
use Convert::Base64;										# base64 encode/decode
use Digest::SHA qw(sha256);

use Cwd qw(abs_path);										# get install/working directory
use File::Basename;

our $install = dirname(abs_path($0));								# get install dir at runtime

require "$install/modules/common.pm";								# yak perl modules
require "$install/modules/aes256.pm";		
require "$install/modules/packet.pm";

my @pkt_hash;											# sha256 hashes of packets (prevents duplicates)
my $client;											# connected clients

$SIG{INT} = \&server_shutdown;									# graceful shutdown (not implemented)

Net::WebSocket::Server->new(									# setup websocket server

	listen => $config->{'port'},								# network port number we listen to

	tick_period => $config->{'tick'},							# seconds between timestamp/tick events (5 seconds or less)

	on_tick => sub {									# timed event handler

		my ($serv, $conn) = @_;

		foreach my $dest ($serv->connections) {						# loop through all connections

			if ( ($client->{$dest}->{'rate'} > $config->{'limit'}) && ($client->{$dest}->{'auth'} ne $config->{'auth'})) {
				print "$client->{$dest}->{'ident'} : DISCONNECTING : Rate limit exceeded ($client->{$dest}->{'rate'})\n";
				$serv->disconnect($dest->{'socket'})
			}
			else {
				if ($client->{$dest}->{'ident'} && $client->{$dest}->{'rate'} > 0) {	# show number of packets received from each client
					print "$client->{$dest}->{'ident'} : $client->{$dest}->{'rate'}\n";
				}
				$client->{$dest}->{'rate'} = 0;
			}
		}
	},

	on_connect => sub {									# connection handler

		my ($serv, $conn) = @_;

		$conn->on(

			handshake => sub {							# new connection
			
				my ($conn, $handshake) = @_;
				$client->{$conn}->{'rate'} = 0;					# initialise rate limiter
				$client->{$conn}->{'ip'} = $conn->ip();				# remember where they connected from

												# TODO : Check blocked list & do something nasty if needed
			},

			disconnect => sub {
				print "$client->{$conn}->{'ident'} : Disconnected\n";
				delete $client->{$conn};
			},

			binary => sub {								# binary data

				my ($conn, $msg) = @_;

				pkt_buffer($conn, $msg, 'BINARY');				# broadcast
			},

			utf8 => sub {								# client sent text/base64 data


				my ($conn, $msg) = @_;

				if ( $msg =~ m/^BINARY/ || $msg =~ m/^BASE64/) {		# subscription
					
					($client->{$conn}->{'transport'}, $client->{$conn}->{'ident'}, $client->{$conn}->{'auth'}) = split(':', $msg);
					$conn->send_utf8("HELLO");					# say hi
					print "$client->{$conn}->{'ident'} : $client->{$conn}->{'ip'} : Connected\n";
				}

				else {								# BASE64 data

					pkt_buffer($conn, $msg, 'BASE64');			# broadcast

				}
			},
		);
	},
)->start;

print("Bye!/n");
exit(0); 		



#############################################################################################################################################################################
#
# shutdown server
#
sub server_shutdown {

	print("Bye!\n");
	exit(0);
}


#############################################################################################################################################################################
#
# add packet to buffer
#
sub pkt_buffer {	

	my ($conn, $raw, $transport) = @_;

	$client->{$conn}->{'rate'}++;							# client rate limiter

	if ($transport eq 'BASE64') {							# convert from BASE64 if needed
		$conn->send_utf8('OK');							# ack
	}
	elsif ($transport eq 'BINARY') {						# default is BINARY
		$conn->send_binary(pack("A*", "OK"));					# ack
	}

	my $packet = packet::parse($raw, [ $config->{'key'} ], $transport );		# parse what we received
	
	if ($packet->{'type'} == $packet::PKT_ENCRYPTED_BCAST) {			# was a broadcast encrypted with our key

		$pkt = packet::parse($packet->{'plaintext'}, [ $config->{'key'} ]);	# parse the decrypted

		if ($pkt->{'type'} < $packet::PKT_BROADCAST) {				# rate limit non-priviledged packets

			my $hash = sha256($packet->{'plaintext'});			# hash the packet
	
			if (!grep $_ eq $hash, @pkt_hash) {				# check for duplicates
				push @pkt_hash, $hash;
		
				if (scalar @pkt_hash > $config->{'tracker'}) {		# control tracker size
					shift @pkt_hash;
				}
		
				broadcast ($conn, $packet->{'plaintext'});	
			}
		}
		else {									# send broadcast packet
			broadcast ($conn, $packet->{'plaintext'});
		}
	}	
}


#############################################################################################################################################################################
#
# broadacast packet
#
sub broadcast {

	my ($conn, $pkt_binary) = @_;					# connections, binary data, base64 data

	my $pkt_base64 = encode_base64($pkt_binary);			# generate base64 

	foreach my $dest ($conn->server->connections) {			# loop through all connections

		if ($conn != $dest) {					# dont send to originating client
			if ($client->{$dest}->{'transport'} eq 'BASE64') {		# - send as base64
				$dest->send_utf8($pkt_base64);
			}
			elsif ($client->{$dest}->{'transport'} eq 'BINARY') {	# - send as binary
				$dest->send_binary($pkt_binary);
			}
		}
	}
}

