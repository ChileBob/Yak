#!/usr/bin/perl
#
# yak-client : simple websocket client for Yak
#
# MIT License (ChileBob)
#
# Zcash : zs1a7qnkg8hr74ujj08jhjcdfs7s62yathqlyn5vd2e8ww96ln28m3t2jkxun5fp7hxjntcg8ccuvs
# Ycash : ys17fsj64ydl93net807xr00ujz2lnrf22cjf4430vvz69vpaat8t3hrdjmkvj7thrw4fdaz7l0pns

use Data::Dumper;					# debugging output
use Time::HiRes q(usleep);				# high res timer
use IO::Socket::INET;					# general purpose networking
use Protocol::WebSocket::Client;			# websocket client
use Convert::Base64;					# transport encoding for perl clients
use String::HexConvert ':all';				# convert hex-encoded strings to ascii

							# ChileBob Packages
							#
require './common.pm';					# common yak subs
require './bech32.pm';					# bech32 encode/decode 
require './aes256.pm';					# AES256 encrypt/decrypt
require './packet.pm';					# yak packet encode/decode

my $config = { 						# DEFAULT CONFIGURATION
	client_ident => aes256::keyRandom(32, 'A'),	# create a new random client ident
	web_type => 'ws',				# websocket server
	web_addr => '127.0.0.1',			#
	web_port => 8834,				#
	debug => 5					# debug verbosity
};

# TODO: process command line to over-ride default config
# TODO: show help, command line args & exit

my $testxfvk = 'zxviews1qwmpy5zhqsqqpqyv8h7n8jjumltlmjwl2hyc8nlk0k2nn4wn2926vj8rhum0d47kq354392kfg4vl4rdcsnnywsxr7j75uqcg8zyaa0v3xx9tgzz4whtfwspw0hnga6mcuslwhwzdz697259z4lqepu7z06wm5szkghuxtsscepks0ya9gs0yur3lsuxs26j5dej2rxqz9qjgk2ds0j45mt6zwx0pzd46ptn3yy5dstz8nv24wql8lwxl5w277nu66vumxutzpa98lq80xkcw';


#########################################################################################################################################################################
#
# CHANGING ANYTHING BELOW THIS LINE IS A REALLY BAD IDEA !! IF YOU BREAK IT, YOU GET TO KEEP THE PEICES
#
#########################################################################################################################################################################

my $running = 1;						# running flag

my $tcp_socket = IO::Socket::INET->new(				# connect to websocket server (blocking)
	PeerAddr => $config->{'web_addr'},			#
	PeerPort => $config->{'web_port'},			#
	Proto => 'tcp',						#
	Blocking => 1						# can be blocking, all we do is send
);

if (!$tcp_socket) {						# confirm connection
	common::debug (0, "WEB: $config->{'web_type'}://$config->{'web_addr'}:$config->{'web_port'} : WARNING!!! NOT CONNECTED!!!");
}
								# start websocket client
my $client = Protocol::WebSocket::Client->new(url => "$config->{'web_type'}://$config->{'web_addr'}:$config->{'web_port'}");

$client->on(							# websocket connect method
	connect => sub {
		my $client = shift;
	}
);

$client->on(
	write => sub {						# websocket write method
		my $client = shift;
		my ($buf) = @_;
		syswrite $tcp_socket, $buf;
		sleep(1);
	}
);

$client->on(							# websocket read method
	read => sub {
		my $client = shift;
		my ($buf) = @_;

		if ($buf =~ m/^HELLO/) {			# parse received messages
			common::debug(0, "Connected!");
		}
		else {
			my $packet = packet::parse(decode_base64($buf), $testxfvk);	
			print Dumper $packet;
		}
	}
);

$client->connect;							# connect to websocket server

$client->write("BASE64:$config->{'client_ident'}");			# subscribe for BASE64 transport & send our client ID

while ($running) {

	if ($tcp_socket) {						# listen to websocket server (if connected)

		my $recv_data;							# read from websocket
		my $bytes_read = sysread $tcp_socket, $recv_data, 16384;	# make sure its correct
	
		if (!defined $bytes_read) { 
			common::debug(0, "Failed to read from socket, aborting.");
			exit;
		}
		elsif ($bytes_read == 0) { 
			common::debug(0, "Websocket connection terminated.");
			exit;
		}
		$client->read($recv_data); 				# this is where we parse what we read....
	}
	usleep 100_00;							# lets not beat up the server, take a nap
}

common::debug(0, "Bye!");

exit;


