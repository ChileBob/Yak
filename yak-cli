#!/usr/bin/perl
#
# yak-cli : Yak command line client
#
# MIT License (ChileBob)
#
# Zcash : zs1a7qnkg8hr74ujj08jhjcdfs7s62yathqlyn5vd2e8ww96ln28m3t2jkxun5fp7hxjntcg8ccuvs
# Ycash : ys17fsj64ydl93net807xr00ujz2lnrf22cjf4430vvz69vpaat8t3hrdjmkvj7thrw4fdaz7l0pns

use Data::Dumper;					# debugging output

use Time::HiRes q(usleep);				# high res timer
use IO::Socket::INET;					# general purpose networking
use Protocol::WebSocket::Client;			# websocket client
use Convert::Base64;					# transport encoding for perl clients
use String::HexConvert ':all';				# convert hex-encoded strings to ascii

use LWP::UserAgent;					# used to POST transaction alerts to URI

							# ChileBob Packages
							#
require './common.pm';					# common yak subs
require './bech32.pm';					# bech32 encode/decode 
require './aes256.pm';					# AES256 encrypt/decrypt
require './packet.pm';					# yak packet encode/decode

my $config = { 						# DEFAULT CONFIGURATION
	ident   => aes256::keyRandom(32, 'A'),		# create a new random client ident
	auth    => 'changethispassword',		# password to bypass yak-yak rate limit
	web 	=> 'ws://127.0.0.1:8834',		# websocket server 
	debug => 5					# debug verbosity
};

$config = common::parse_argv($config, \@ARGV); 		# process command line to over-ride default config

# TODO: show help, command line args & exit

my $testxfvk = 'zxviews1qwmpy5zhqsqqpqyv8h7n8jjumltlmjwl2hyc8nlk0k2nn4wn2926vj8rhum0d47kq354392kfg4vl4rdcsnnywsxr7j75uqcg8zyaa0v3xx9tgzz4whtfwspw0hnga6mcuslwhwzdz697259z4lqepu7z06wm5szkghuxtsscepks0ya9gs0yur3lsuxs26j5dej2rxqz9qjgk2ds0j45mt6zwx0pzd46ptn3yy5dstz8nv24wql8lwxl5w277nu66vumxutzpa98lq80xkcw';


#########################################################################################################################################################################
#
# CHANGING ANYTHING BELOW THIS LINE IS A REALLY BAD IDEA !! IF YOU BREAK IT, YOU GET TO KEEP THE PEICES
#
#########################################################################################################################################################################

my $running = 1;						# running flag

my ($web_type, $web_ip, $web_port) = common::uri_split($config->{'web'});

my $tcp_socket = IO::Socket::INET->new(				# connect to websocket server (blocking)
	PeerAddr => $web_ip,					#
	PeerPort => $web_port,					#
	Proto => 'tcp',						#
	Blocking => 1						# can be blocking, all we do is send
);

if (!$tcp_socket) {						# confirm connection
	common::debug (0, "WEB: $config->{'web'} : WARNING!!! NOT CONNECTED!!!");
}
								# start websocket client
my $client = Protocol::WebSocket::Client->new(url => "$config->{'web'}");

$client->on(							# websocket connect 
	connect => sub {
		my $client = shift;
	}
);

$client->on(
	write => sub {						# websocket write
		my $client = shift;
		my ($buf) = @_;
		syswrite $tcp_socket, $buf;
	}
);

$client->on(							# websocket read
	read => sub {

		my $client = shift;
		my ($buf) = @_;

		if ($buf =~ m/^HELLO/) {			# parse received messages
			common::debug(0, "Connected!");
		}
		else {

			my $packet = packet::parse(decode_base64($buf), $testxfvk);	

			if ($packet->{'type'} == $packet::PKT_TRANSPARENT) {
#				common::debug(0, 'TRANSPARENT NOTIFICATION');
#				print Dumper $packet;
			}
			elsif ($packet->{'type'} == $packet::PKT_SHIELDED) {
				common::debug(0, 'SHIELDED NOTIFICATION');
				print Dumper $packet;
			}
			elsif ($packet->{'type'} == $packet::PKT_CONFIRMATION) {
#				common::debug(0, 'TRANSACTION CONFIRMATION');
#				print Dumper $packet;
			}
			elsif ($packet->{'type'} == $packet::PKT_ANNOUNCE) {
#				common::debug(0, 'NODE ANNOUNCEMENT');
#				print Dumper $packet;
			}
			elsif ($packet->{'type'} == $packet::PKT_HEARTBEAT) {
#				common::debug(0, 'HEARTBEART');
			}
		}
	}
);

$client->connect;						# connect to websocket server
sleep(2);							# yak-yak needs a little time

$client->write("BASE64:$config->{'ident'}:$config->{'auth'}");	# subscribe for BASE64 transport, send ident & auth

while ($running) {

	if ($tcp_socket) {						# listen to websocket server (if connected)

		my $recv_data;							# read from websocket
		my $bytes_read = sysread $tcp_socket, $recv_data, 16384;	# make sure its correct
	
		if (!defined $bytes_read) { 
			common::debug(0, "Failed to read from socket, aborting.");
			exit;
		}
		elsif ($bytes_read == 0) { 
			common::debug(0, "Websocket connection terminated.");
			exit;
		}
		$client->read($recv_data); 				# this is where we parse what we read....
	}
	usleep 100_00;							# lets not beat up the server, take a nap
}

common::debug(0, "Bye!");

exit;


