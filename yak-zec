#!/usr/bin/perl
#
# yak-zec : node client for zcash
#
# MIT License (ChileBob)
#
# Zcash : zs1a7qnkg8hr74ujj08jhjcdfs7s62yathqlyn5vd2e8ww96ln28m3t2jkxun5fp7hxjntcg8ccuvs
# Ycash : ys17fsj64ydl93net807xr00ujz2lnrf22cjf4430vvz69vpaat8t3hrdjmkvj7thrw4fdaz7l0pns

# TODO: Process command line args to overwrite default settings
# TODO: Add messaging to clients for when a viewkey is added/removed

# ISSUE: Would be nice to ONLY support IVKs as a payment detector does not need to know about outgoing transactions.
# ISSUE: The payment address cannot be derived from an IVK, so maybe not.
#
# BUG: Large transactions can exceed the max websocket limits
# - break into sections
# - add sections to outbound spool

#########################################################################################################################################################################
#
# HEALTH WARNING !
#
# - Running ZMQ on a fullnode may compromise its security even if restricted to 127.0.0.1
#
#########################################################################################################################################################################

use Data::Dumper;					# debugging

use ZMQ::FFI qw(ZMQ_SUB);				# ZMQ connection to fullnode
use Time::HiRes q(usleep);				# ZMQ polling interval timer
use Math::BigInt;					# at some point we need to handle 256-bit ints
use IO::Socket::INET;					# general purpose networking
use Protocol::WebSocket::Client;			# websocket client
use Convert::Base64;					# transport encoding for perl clients
use Convert::Binary::C;					# the Rust things are designed to work with C so Perl needs this
use String::HexConvert ':all';				# convert hex-encoded strings to ascii

use FFI::Platypus;					# FFI interface to librustzcash
use FFI::Platypus::Buffer qw( scalar_to_buffer);	# 
use FFI::Platypus::Memory qw( malloc memcpy free);	# 

							# ChileBob Packages
							#
require './common.pm';					# common subs
require './bech32.pm';					# bech32 encode/decode 
require './aes256.pm';					# AES256 encrypt/decrypt
require './packet.pm';					# yak packet generation/parsing

my $config = { 						# DEFAULT CONFIGURATION

	nodename => 'ChileBobs Yak Node (Zcash)',	# name of this node for announcements
	price => 10,					# price per block for monitoring a viewkey (zats)
	timer_reset => 6000,				# interval reset value (60 seconds)
	timer_count => 0,				# interval timer live count
	client_ident => aes256::keyRandom(32,'A'),	# client ident, randomised
	debug => 5,					# debugging output level
	node_client => 'zcash-cli',			# fullnode client binary
	zmq => 'tcp://127.0.0.1:28232',			# fullnode zmq
	web_type => 'ws',				# websocket server
	web_addr => '127.0.0.1',			#
	web_port => 8834,				#
	librust => '/home/bob/github/zcash/target/debug/librustzcash.so',		# path to librustzcash.so (dynamic library built from librustzcash)
	xfvk => 'zxviews1q0kl7tavzyqqpq8efe0vpgzwc37zj0zr9j2quurncpsy74tdvh9c3racve9yfv6gkssvekw4sz6ueenvup6whupguzkg5rgp0kma37r4uxz9472w4zwra4jv6fm5dc2cevfpjsxdgndagslmgdwudhv4stklzfeszrlcnsqxyr2qt8tsf4yxs3he4rzllcly7xagfmnlycvvnvhhr9l9j6ad693rkueqys9f7mkc7aacxwp3tfc9hpvlckxnj4nwu6jef2x98jefhcgmpkrmn'
};

# TODO: config for websocket connection should be a URI, not seperate components for protocol/address/port
# TODO: process command line to over-ride default config
# TODO: show help, command line args & exit


#########################################################################################################################################################################
#
# CHANGING ANYTHING BELOW THIS LINE IS A REALLY BAD IDEA !! IF YOU BREAK IT, YOU GET TO KEEP THE PEICES
#
#########################################################################################################################################################################

my $running = 1;						# running flag

my $ffi = FFI::Platypus->new( api => 1);												# FFI to librustzcash
$ffi->lib( $config->{'librust'} );													# load library

$ffi->attach( 'librustzcash_xfvk_decrypt_note' => [ 'int', 'string', 'string', 'string', 'string', 'opaque', 'opaque' ] => 'int');	# decrypt note with ExtendedFullViewingKey 
$ffi->attach( 'librustzcash_zip32_xfvk_address' => [ 'string', 'string', 'opaque', 'opaque'  ] => 'int'); 				# derive payment address from ExtendedFullViewingKey
$ffi->attach( 'librustzcash_crh_ivk' => [ 'string', 'string', 'opaque' ] => 'void'); 							# derive ivk from ak & nk

my @viewkey;							# array of ExtendedFullViewingKeys being monitored
my %viewkey_expiry;						# hash of xfvks & expiry block number

$config->{'xfvk'} = xfvk_check($config->{'xfvk'});		# check our registration key is valid

if ($config->{'xfvk'}) {	
	push(@viewkey, $config->{'xfvk'});
	$config->{'addr'} = xfvk_to_addr($config->{'xfvk'});	# derive address from xfvk
	common::debug(0, "REG: $config->{'addr'}");
}
else {								# MUST have a valid registration viewkey
	print("Registration viewkey is NOT VALID ! Aborting\n");
	exit(1);
}

common::debug(0, "ID : $config->{'client_ident'}");		# show connection detail
common::debug(0, "ZMQ: $config->{'zmq'}");

my $ctx = ZMQ::FFI->new();					# ZMQ connection

my $zmq_socket = $ctx->socket(ZMQ_SUB);				# ZMQ socket
$zmq_socket->connect($config->{'zmq'});				# 
$zmq_socket->subscribe('');					# 

my $tcp_socket = IO::Socket::INET->new(				# connect to websocket server (blocking)
	PeerAddr => $config->{'web_addr'},			#
	PeerPort => $config->{'web_port'},			#
	Proto => 'tcp',						#
	Blocking => 1						# can be blocking, all we do is send
);

if (!$tcp_socket) {						# confirm connection
	common::debug (0, "WEB: $config->{'web_type'}://$config->{'web_addr'}:$config->{'web_port'} : WARNING!!! NOT CONNECTED!!!");
}
								# start websocket client
my $client = Protocol::WebSocket::Client->new(url => "$config->{'web_type'}://$config->{'web_addr'}:$config->{'web_port'}");

$client->on(							# websocket connect method
	connect => sub {
		my $client = shift;
	}
);

$client->on(
	write => sub {						# websocket write method
		my $client = shift;
		my ($buf) = @_;

		syswrite $tcp_socket, $buf;
		usleep 100_00;	
	}
);

$client->on(							# websocket read method
	read => sub {
		my $client = shift;
		my ($buf) = @_;

		common::debug($config->{'debug'}, "RX: $buf");

		if ($buf =~ m/^HELLO/) {			# receive server welcome message
			common::debug($config->{'debug'}, "Connected!");
		}
		else {
			common::debug($config->{'debug'}, unpack("H*", $buf));
# TODO: Parse received packets
		}

	}
);

$client->connect;							# connect to websocket server

$client->write("BASE64:$config->{'client_ident'}");			# subscribe for BASE64 transport & send our random session/client ID

my $info  = node_cli('getblockchaininfo', '', 'abort');			# current chain info, abort if node is down

my $block = node_cli('getblock', $info->{'bestblockhash'}, 'abort');	# last block, abort if node is down

									# load viewkeys from memos received by registration address

my $txn_reg = node_cli("z_listreceivedbyaddress $config->{'addr'}");	# get all transactions received by registration address
if (!$txn_reg) {
	common::debug(0, "The zaddr (or viewkey) for registration is not in the node wallet!! Aborting!!");
	exit(1);
}

foreach my $txn ( @{$txn_reg} ) {					# loop through transactions to registration address

	my @line = split("\n", hex_to_ascii($txn->{'memo'})); 		# convert memos to ascii, split into lines

	foreach $line (@line) {						# we don't control the format so check each line
		$line =~ s/\0//g;					# strip nulls

		if (xfvk_check($line)) {				# check for valid extended full viewing key

			my $status = "ACTIVE ";
			my $endblock = ($txn->{'amountZat'} / $config->{'price'}) + $txn->{'blockheight'};

			if ($endblock < $block->{'height'}) {		# expired registration, don't load the viewkey
				$status = "Expired";
			}
			else {						# active registration
				push(@viewkey, $line);	
				$viewkey_expiry{$line} = $endblock;	# log the expiry block
			}
			print "$status : Blks: $txn->{'blockheight'}-$endblock, " . xfvk_to_addr($line) . "\n";
		}
	}
}

while ($running) {
	if ($tcp_socket) {						# listen to websocket server (if connected)

		my $recv_data;							# read from websocket
		my $bytes_read = sysread $tcp_socket, $recv_data, 16384;	# make sure its correct
	
		if (!defined $bytes_read) { 
			common::debug(0, "Failed to read from network socket, aborting.");
			exit;
		}
		elsif ($bytes_read == 0) { 
			common::debug(0, "Websocket connection terminated");
			exit;
		}
		$client->read($recv_data);
	}

	until ($zmq_socket->has_pollin) {			# wait until zmq says something
		usleep 100_00;


		$config->{'timer_count'}--;					# interval timer

		if ($config->{'timer_count'} <= 0) {	

			$config->{'timer_count'} = $config->{'timer_reset'};

			my @announce = ( 					# generate announcement
				pack("L", $config->{'price'}), 
				pack("A78", $config->{'addr'}), 
			);

			common::debug($config->{'debug'}, "checking node...");	# check node status
			$info  = node_cli('getblockchaininfo', '', '');

			if ($info) {						# append node status
				push @announce, pack("C", 1);
			}
			else {
				push @announce, pack("C", 0);
			}
			push @announce, pack("a512", $config->{'nodename'});	# append node name

			if ($tcp_socket) {					# send if connected
				my $raw = packet::generate(0x03, \@announce, '');
				$client->write(encode_base64(packet::generate(0x03, \@announce, '')));
			}
		}
	}

	if ($zmq_socket->has_pollin) {

		my @zmq_parts = $zmq_socket->recv_multipart();									# read ZMQ

		if ($zmq_parts[0] eq 'rawtx') {											# raw transaction	
				
			my $txn = node_cli('decoderawtransaction', unpack("H*", $zmq_parts[1]), '');	# node client decodes raw transaction, dont abort on failure

			my @vout            = @{$txn->{'vout'}};								# array of transparent outputs
			my @vShieldedOutput = @{$txn->{'vShieldedOutput'}};							# shielded outputs

			my @data = ( pack("H*", $txn->{'txid'}) );								# 32-bytes, txid is the first record
	

			foreach $op (@vout) {
				common::debug($config->{'debug'}, "$op->{'scriptPubKey'}->{'addresses'}[0] : $op->{'valueZat'}");

				my $value = pack("H*", sprintf("%016X", $op->{'valueZat'}));				# 8-bytes, valueZat
				my $addr  = pack("A*", $op->{'scriptPubKey'}->{'addresses'}[0]);			# 35-char taddr

				push @data, ("$value$addr");
			}

			if ( (scalar @data > 1) && $tcp_socket ){							# send transparent outputs, if we have any and connection is up
# TODO: packet::generate() : change to use arrayref of packets
				$client->write(encode_base64(packet::generate(0, \@data)));				# broadcast
			}
	
			@data = ( pack("H*", $txn->{'txid'}) );									# 32-bytes, txid is the first record
	
			OUTPUT: foreach my $vout (@{$txn->{'vShieldedOutput'}}) {						# loop through all shielded outputs
	
				VIEWKEY: foreach my $xfvk (@viewkey) {								# loop through all viewkeys

					my $result = decrypt_note ($block->{'height'}, $xfvk, $vout->{'cmu'}, $vout->{'ephemeralKey'}, $vout->{'encCiphertext'});
	
					if ($result->{'status'} == 1) {								# decrypted !!! Wooooo!!!! 

						my $value = hex(unpack("H*", $result->{'value'}));

						if ($xfvk eq $viewkey[0]) {							# registration viewkey ?
					
							my @line = split("\n", unpack("A*", $result->{'memo'}));		# handle multiline memos, we have no control on format here

							MEMOLINE : foreach $line (@line) {					# loop through each line

								$line = xfvk_check($line);					# is it a valid ExtendedFullViewingKey ?
								if ($line) {
									
									common::debug($common->{'debug'}, "****** SHIELDED REGISTRATION ****** : " . xfvk_to_addr($line) . " : " . $value . " zats");
									push(@viewkey, $line);								# append viewkey to monitored array
									$viewkey_expiry{$line} = ($value / $config->{'price'}) + $block->{'height'};	# expiry blocknumber 
									last MEMOLINE;				
								}
							}
						}
						else {										# monitored viewkey
							common::debug($config->{'debug'}, "******* SHIELDED TRANSACTION ****** : " . $value . " : " . unpack("A*", $result->{'memo'}));

							push @data, aes256::encrypt(aes256::keyGen($xfvk), $result->{'value'} . $result->{'memo'}); 	# re-encrypt using viewkey (preserve null-padding!)
						}
						last VIEWKEY;									# we're done! skip remaining keys
					}
				}
			}

			if ( (scalar @data > 1) && $tcp_socket) {								# send shielded outputs, if we have any and are connected
# TODO: packet::generate() : changing to use arrayref of packets
				$client->write(encode_base64(packet::generate(1, \@data)));					# broadcast
			}
		}
	
		elsif ($zmq_parts[0] eq 'hashblock') {										# new block, confirm mined txn
	
			$block = node_cli('getblock', unpack("H*", $zmq_parts[1]), 'abort');					# update block, abort on failure

			my $packet = pack("H*",'0100');										# websocket packet, type 0x01, version 0x00
			$packet .= pack("L", scalar @{$block->{'tx'}});								# 32-bit, count of txids
	
			foreach my $txid (@{$block->{'tx'}}) {									# 32-bytes each, txids mined in this block
				common::debug($config->{'debug'}, "Confirming: $txid");						#
				$packet .= pack("H*",$txid);									# 
			}
	
			if ($tcp_socket) {											# send to websocket server (if connected)
				$client->write(encode_base64($packet));		
			}

			my @validkeys = ( $viewkey[0] );
			foreach my $key (keys %viewkey_expiry) {								# check viewkey expiry info
				if ($viewkey_expiry{$key} >= $block->{'height'}) {						# still valid, copy it
					push(@validkeys, $key);
				}
				else {												# key expired, remove from monitoring
					common::debug(0, "Key Expired : $key");
					delete $viewkey_expiry{$key};
				}
			}
			@viewkey = @validkeys;											# replace array of monitored keys

		}
	}	
}

common::debug(0, "Bye!");

exit;


#############################################################################################################################################################################
#
# query node client, return JSON 
#
sub node_cli {

	use JSON;

	my ($command, $data, $failure) = @_;

	my $response = `$config->{'node_client'} $command $data 2>/dev/null`;		# every time you use backticks a puppy dies :-(

	if (eval { decode_json($response) } ) {						# invalid kills puppys too
		return(decode_json($response));
	}
	else {										# bad response
		if ($failure eq 'abort') {						# 'abort' flag means we shutdown now
			print("Node is down, aborting\n");
			exit(1);
		}
	}
}


#############################################################################################################################################################################
#
# LIBRUSTZCASH : subs that summon librustzcash functions
#
#############################################################################################################################################################################

# Derive incoming viewkey from extended full viewkey
#
# TODO: IVK support ?
#
sub xfvk_to_ivk {

	my ($xfvk_str) = @_;

	$xfvk_str = xfvk_check($xfvk_str);						# check length & prefix
	if (!$xfvk_str) {								# 
		return(0);
	}

	my $xfvk = bech32::decode_bech32($xfvk_str);					# extended full viewkey (285 chars)
	my $ak = substr($xfvk, 0,  32);							# ak 
	my $nk = substr($xfvk, 32, 32);							# nk 
	my $ovk = substr($xfvk, 64, 32);						# output view key
	# dk 										# diversifier key
	# c										# chain code

	my $ivk_ret = pack("c32", 0);							# allocate memory for response
	my ($ivk_ptr, $ivk_size) = scalar_to_buffer $ivk_ret;

	librustzcash_crh_ivk ($ak, $nk, $ivk_ptr);					# where the magic happens

	return(unpack("H*", $ivk_ret));							# return ivk as hex string
}


#######################################################################################################################################
#
# Derive payment address from extended full viewkey 
#
sub xfvk_to_addr {

	my ($xfvk_str) = @_;								# bech32 encoded extended full viewkey

	$xfvk_str = xfvk_check($xfvk_str);						# check length & prefix
	if (!$xfvk_str) {								# 
		return(0);
	}
	else {

		my $xfvk = bech32::decode_bech32($xfvk_str);				# full viewkey (285 chars)

		my $j   = pack("c11", 0);						# diversifier (11 bytes);

		my $j_ret    			= pack("c11", 0);			# RETURNED diversifier
		my ($j_ptr, $j_size)		= scalar_to_buffer $j_ret;		#

		my $addr_ret 			= pack("c43", 0);			# RETURNED address
		my ($addr_ptr, $addr_size) 	= scalar_to_buffer $addr_ret;		#

		librustzcash_zip32_xfvk_address( $xfvk, $j, $j_ptr, $addr_ptr);		# where the magic happens

		return(bech32::encode_bech32('zs', $addr_ret));				# return as bech32 encoded string
	}
}


#######################################################################################################################################
#
# Attempt to decode a sapling transaction 
#
sub decrypt_note {

	my ($height, $xfvk, $cmu, $epk, $enc_ciphertext) = @_;				# height (int), hex-encoded strings (all other vars)

	$xfvk = xfvk_check($xfvk);							# check viewkey for length & prefix
	if (!$xfvk) {									# 
		return(0);
	}

	my $value_ret    			= pack("c8", 0);			# allocate memory for returned values
	my ($value_ptr, $value_size)		= scalar_to_buffer $value_ret;		#	
											#
	my $memo_ret    			= pack("c512", 0);			# 
	my ($memo_ptr, $memo_size)		= scalar_to_buffer $memo_ret;		#	

	my $result = librustzcash_xfvk_decrypt_note(					# where the magic happens
		$height,	 								# (u32) 	block height
		pack("A285", $xfvk), 								# (285-bytes)	full viewkey
		pack("H64", $cmu), 								# (32-bytes)	commitment u-coordinate	
		pack("H64", $epk), 								# (32-bytes)	ephemeral key	
		pack("H1160", $enc_ciphertext),							# (580-bytes)	encrypted 

		$value_ptr,									# (8-bytes)	value (u64)
		$memo_ptr									# (512-bytes)	memo (null padded)
	);

	return( {status => $result, addr => $addr_ret, value => $value_ret, memo => $memo_ret} );
}


#######################################################################################################################################
#
# Check Extended Full Viewing Key
#
sub xfvk_check {

	my ($xfvk_str) = @_;				# bech32 encoded extended full viewkey

	$xfvk_str =~ s/\0//g;				# strip null padding
	$xfvk_str =~ s/\s//g;				# strip whitespace

	if (index($xfvk_str, 'zxviews') != 0) {
		common::debug($config->{'debug'}, "xfvk_to_addr() : full viewkey had the wrong prefix, expected \'zxviews\', received \'$xfvk_str\'");
		return(0);
	}
	elsif (length($xfvk_str) < 285) {			
		common::debug($config->{'debug'}, "xfvk_to_addr() : full viewkey too short, expected 285 chars, received " . length($xfvk_str) . " bytes" . "\n");
		return(0);
	}

	$xfvk_str = substr($xfvk_str,0,285);		# chop key to correct length
	return($xfvk_str);				# viewing key is valid, return cleaned value
}

