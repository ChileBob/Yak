#!/usr/bin/perl
#
# yak-zec : node client for zcash
#
# MIT License (ChileBob)
#
# Zcash : zs1a7qnkg8hr74ujj08jhjcdfs7s62yathqlyn5vd2e8ww96ln28m3t2jkxun5fp7hxjntcg8ccuvs
# Ycash : ys17fsj64ydl93net807xr00ujz2lnrf22cjf4430vvz69vpaat8t3hrdjmkvj7thrw4fdaz7l0pns

# TODO: Process command line args to overwrite default settings
# TODO: Confirm zaddr derived from FVK has been imported to the node, otherwise abort
# TODO: Use the viewkey as an encryption key & AES256 encrypt shielded outputs BEFORE sending
# TODO: Add pricing/expiry for viewkey monitoring, zats per block seems a good method
# TODO: Add messaging to clients for when a viewkey is added/removed

# ISSUE: Would be nice to ONLY support IVKs as a payment detector does not need to know about outgoing transactions.
# ISSUE: The payment address cannot be derived from an IVK, so maybe not.

#########################################################################################################################################################################
#
# HEALTH WARNING !
#
# - Running ZMQ on a fullnode may compromise its security even if restricted to 127.0.0.1
#
#########################################################################################################################################################################
#
# - Websocket update encoding :-
#
# 	<type>		u8										('0x00' : type, '0x00' = mempool txn)
# 	<version>	u8										('0x01' : version)
# 	<txid>		32-bytes									(txid)
# 	<taddr count>	uint32										(number of transparent outputs)
# 	<taddr data>	<taddr_count> * (<amount 8-bytes> + <address 35-bytes>)				(transparent output data)
# 	<zaddr count>	uint32										(number of shielded outputs)
#	<zaddr data>	<zaddr_count> * (<amount 8-bytes> + <memo 512-bytes>)				(decoded shielded output data)
#
#	<type>		u8										('0x01' : type, txn confirmation)
#	<version>	u8										('0x00' : version)
#	<txid count>	uint32										(number of txids)
#	<txid data>	<count * 32-bytes>								(txids)
#
#########################################################################################################################################################################

use ZMQ::FFI qw(ZMQ_SUB);				# ZMQ connection to fullnode
use Time::HiRes q(usleep);				# ZMQ polling interval timer
use Data::Dumper;					# debugging output
use Math::BigInt;					# at some point we need to handle 256-bit ints
use IO::Socket::INET;					# general purpose networking
use Protocol::WebSocket::Client;			# websocket client
use Convert::Base64;					# transport encoding for perl clients
use Convert::Binary::C;					# the Rust things are designed to work with C so Perl needs this
use String::HexConvert ':all';				# convert hex-encoded strings to ascii

use Crypt::CBC;						# encryption mode
use Crypt::Cipher::AES;					# AES256 encryption algo
use Digest::SHA qw(sha256);				# sha hashing strings to create keys

use FFI::Platypus;					# FFI interface to librustzcash
use FFI::Platypus::Buffer qw( scalar_to_buffer);	# 
use FFI::Platypus::Memory qw( malloc memcpy free);	# 

require './bech32.pm';					# bech32 encode/decode 

my $debug = 1;						# debug mode, 0 = quiet

my $config = { 						# DEFAULT CONFIGURATION

	node_client => 'zcash-cli',			# fullnode client binary
	zmq => 'tcp://127.0.0.1:28232',			# fullnode zmq
	web_type => 'ws',				# websocket server
	web_addr => '127.0.0.1',			#
	web_port => 8834,				#
	librust => '/home/bob/github/zcash/target/debug/librustzcash.so',		# path to librustzcash.so (dynamic library built from librustzcash)
	xfvk => 'zxviews1q0kl7tavzyqqpq8efe0vpgzwc37zj0zr9j2quurncpsy74tdvh9c3racve9yfv6gkssvekw4sz6ueenvup6whupguzkg5rgp0kma37r4uxz9472w4zwra4jv6fm5dc2cevfpjsxdgndagslmgdwudhv4stklzfeszrlcnsqxyr2qt8tsf4yxs3he4rzllcly7xagfmnlycvvnvhhr9l9j6ad693rkueqys9f7mkc7aacxwp3tfc9hpvlckxnj4nwu6jef2x98jefhcgmpkrmn',
	taddr => 1					# ignore transparent txns by default
};

#TODO: process command line to over-ride default config
#TODO: show help, command line args & exit


#########################################################################################################################################################################
#
# CHANGING ANYTHING BELOW THIS LINE IS A REALLY BAD IDEA !! IF YOU BREAK IT, YOU GET TO KEEP THE PEICES
#
#########################################################################################################################################################################

my $running = 1;						# running flag

my $timeout_reset = 1000;					# timeout counter (10 seconds)
my $timeout = $timeout_reset;

my $ffi = FFI::Platypus->new( api => 1);												# FFI to librustzcash
$ffi->lib( $config->{'librust'} );													# load library

$ffi->attach( 'librustzcash_xfvk_decrypt_note' => [ 'int', 'string', 'string', 'string', 'string', 'opaque', 'opaque' ] => 'int');	# decrypt note with ExtendedFullViewingKey 
$ffi->attach( 'librustzcash_zip32_xfvk_address' => [ 'string', 'string', 'opaque', 'opaque'  ] => 'int'); 				# derive payment address from ExtendedFullViewingKey
$ffi->attach( 'librustzcash_crh_ivk' => [ 'string', 'string', 'opaque' ] => 'void'); 							# derive ivk from ak & nk

my @viewkey;							# array of ExtendedFullViewingKeys we monitor

$config->{'xfvk'} = xfvk_check($config->{'xfvk'});		# check our registration key is valid

if ($config->{'xfvk'}) {	
	push(@viewkey, $config->{'xfvk'});
	$config->{'addr'} = xfvk_to_addr($config->{'xfvk'});	# derive address from xfvk
	debug("REG: $config->{'addr'}");
}
else {								# MUST have a valid registration viewkey
	print("Registration viewkey is NOT VALID ! Aborting\n");
	exit(1);
}

my $client_ident = keyRandom(32,'A');				# generate random client id for this client
debug("ID : $client_ident");				

debug("ZMQ: $config->{'zmq'}");
my $ctx = ZMQ::FFI->new();					# ZMQ connection

my $zmq_socket = $ctx->socket(ZMQ_SUB);				# ZMQ socket
$zmq_socket->connect($config->{'zmq'});				# 
$zmq_socket->subscribe('');					# 

my $tcp_socket = IO::Socket::INET->new(				# connect to websocket server (blocking)
	PeerAddr => $config->{'web_addr'},			#
	PeerPort => $config->{'web_port'},			#
	Proto => 'tcp',						#
	Blocking => 1						# can be blocking, all we do is send
);

if (!$tcp_socket) {						# confirm connection
	debug ("WEB: $config->{'web_type'}://$config->{'web_addr'}:$config->{'web_port'} : WARNING!!! NOT CONNECTED!!!");
}
								# start websocket client
my $client = Protocol::WebSocket::Client->new(url => "$config->{'web_type'}://$config->{'web_addr'}:$config->{'web_port'}");

$client->on(							# websocket connect method
	connect => sub {
		my $client = shift;
	}
);

$client->on(
	write => sub {						# websocket write method
		my $client = shift;
		my ($buf) = @_;
		syswrite $tcp_socket, $buf;
		usleep 100_00;	
	}
);

$client->on(							# websocket read method
	read => sub {
		my $client = shift;
		my ($buf) = @_;

		debug("RX: $buf");

		if ($buf =~ m/^HELLO/) {			# receive server welcome message
			debug("Connected to socket server");
		}
	}
);

$client->connect;							# connect to websocket server

$client->write("BASE64:$client_ident");					# subscribe for BASE64 transport & send our random session/client ID

my $info  = node_cli('getblockchaininfo', '', 'abort');			# current chain info, abort if node is down

my $block = node_cli('getblock', $info->{'bestblockhash'}, 'abort');	# last block, abort if node is down

									# load viewkeys from memos received by registration address
									
foreach my $txn (@{node_cli("z_listreceivedbyaddress $config->{'addr'}")}) {	# check registration address for viewkeys to load

	my @line = split("\n", hex_to_ascii($txn->{'memo'})); 			# convert to ascii & split it lines

	foreach $line (@line) {		
		$line =~ s/\0//g;					# strip nulls
		if (xfvk_check($line)) {				# add if valid
			push(@viewkey, $line);				# TODO: Prob want to check min value before adding, unless its free :-)
			print "Monitoring : " . xfvk_to_addr($line) . "\n";
		}
	}
}
debug("Monitoring " . scalar @viewkey . " viewkeys\n");			# ready


while ($running) {
	if ($tcp_socket) {						# listen to websocket server (if connected)

		my $recv_data;							# read from websocket
		my $bytes_read = sysread $tcp_socket, $recv_data, 16384;	# make sure its correct
	
		if (!defined $bytes_read) { 
			debug("Failed to read from network socket");
			exit;
		}
		elsif ($bytes_read == 0) { 
			debug("Websocket connection terminated");
			exit;
		}
	}

	$timeout = $timeout_reset;

	until ($zmq_socket->has_pollin || ($timeout == 0) ) {			# wait until zmq says something
		usleep 100_00;
		$timeout--;
	}

	if ($zmq_socket->has_pollin) {

		$timeout = $timeout_reset;					# reset timeout counter;

		my @zmq_parts = $zmq_socket->recv_multipart();			# read ZMQ

		if ($zmq_parts[0] eq 'rawtx') {					# raw transaction	
				
			my $txn = node_cli('decoderawtransaction', unpack("H*", $zmq_parts[1]), '');	# node client decodes raw transaction, dont abort on failure

			my @vout            = @{$txn->{'vout'}};		# transparent outputs
			my @vShieldedOutput = @{$txn->{'vShieldedOutput'}};	# shielded outputs
	
			my $packet = pack("H*", '0000');			# websocket packet, type 0x00, version 0x00
			$packet .= $zmq_parts[1];				# 32-bytes, txid received from ZMQ
	
			if ($config->{'taddr'} > 0) {				# default is to ignore transparent outputs
				$packet .= pack("L", scalar @vout);		# 32-bit, count of transparent outputs
				foreach $op (@vout) {
					debug("$op->{'scriptPubKey'}->{'addresses'}[0] : $op->{'valueZat'}");
					$packet .= pack("H*", sprintf("%016s", substr(Math::BigInt->new($op->{'valueZat'})->as_hex(), 2)));	# 8-bytes, valueZat
					$packet .= pack("A35", $op->{'valueZat'});								# 35-bytes, address
				}
			}
			else {							# ignore transparent outputs
				$packet .= pack("L", 0);
			}
	
			my $shielded_count = 0;
			my $shielded_data = '';
	
			OUTPUT: foreach my $vout (@{$txn->{'vShieldedOutput'}}) {
	
				VIEWKEY: foreach my $xfvk (@viewkey) {			# try all our viewkeys

					my $result = decrypt_note ($block->{'height'}, $xfvk, $vout->{'cmu'}, $vout->{'ephemeralKey'}, $vout->{'encCiphertext'});
	
					if ($result->{'status'} == 1) {		# decrypted !!! Wooooo!!!! 

						if ($xfvk eq $viewkey[0]) {	# is this our registration viewkey ?
					
							my @line = split("\n", unpack("A*", $result->{'memo'}));		# could be multiline
							foreach $line (@line) {							# check each line

								$line = xfvk_check($line);					# is it a valid ExtendedFullViewingKey ?
								if ($line) {
									debug("****** SHIELDED REGISTRATION ****** : " . xfvk_to_addr($line) . " : " . hex(unpack("H*", $result->{'value'})));
									push(@viewkey, $line);					# TODO: Prob want to check min value before adding, unless its free :-)
								}
							}
						}
						else {				# monitored shielded address

							debug("******* SHIELDED TRANSACTION ****** : " . hex(unpack("H*", $result->{'value'})) . " : " . unpack("A*", $result->{'memo'}));
	
							$shielded_count++;							# TODO: Increase count of shielded transactions	
							my $shielded_out .= $result->{'value'};	# 8-bytes, value in zats	# TODO: Add shielded data
						        $shielded_out    .= $result->{'memo'};	# 512 bytes, null padded memo
	
																# TODO: Encrypt AES256 with xfvk as the excryption key
							$shielded_data .= $shielded_out;					# TODO: Append ciphertext 
						}

						last VIEWKEY;									# break out of the loop, no need to try remaining keys
					}
				}
			}
			$packet .= pack("L", $shielded_count);			# TODO: 32-bit, count of decoded shielded outputs
			$packet .= $shielded_data; 				# TODO: Append shielded output ciphertext
	
			if ($tcp_socket) {					# send to websocket server (if connected)
				$client->write(encode_base64($packet));		
			}
		}
	
		elsif ($zmq_parts[0] eq 'hashblock') {				# new block, confirm mined txn
	
			$block = node_cli('getblock', unpack("H*", $zmq_parts[1]), 'abort');	# update block, abort on failure
	
			my $packet = pack("H*",'0100');				# websocket packet, type 0x01, version 0x00
			$packet .= pack("L", scalar @{$block->{'tx'}});		# 32-bit, count of txids
	
			foreach my $txid (@{$block->{'tx'}}) {			# 32-bytes each, txids mined in this block
				debug("Confirming: $txid");
				$packet .= pack("H*",$txid);			# 32-bytes each
			}
	
			if ($tcp_socket) {					# send to websocket server (if connected)
				$client->write(encode_base64($packet));		
			}
		}
	}	
	else {									# timeout, so check node is still up or abort
		$info  = node_cli('getblockchaininfo', '', 'abort');
	}
	$timeout = $timeout_reset;						# node is OK, reset timeout
}

debug("exit...");

exit;


#########################################################################################################################################################################
#
# debugging
#
sub debug {
	
	# TODO : Send to logfile ? Maybe not (privacy!)
	if ($debug) {
		print "$_[0]\n";
	}
}


#######################################################################################################################################
#
# generate random hex string to use as a key (64 hex chars only, 32 bytes, 256-bits) 
#
sub keyRandom {	

	my ($key_length, $key_type) = @_;

	my @chars = ('a'..'z', 'A'..'Z', '0'..'9');
	if ($key_type eq "") {						# alpha string if any key type arg is given
		@chars = ('a'..'f', '0'..'9');				# default key type : lower case hex string
	}

	if ($key_length eq "") {					# default key length is 64 chars
		$key_length = 64;
	}

	my $key_random = '';					
	$key_random .= $chars[rand @chars] for 1..$key_length;		# add random chars 

	return($key_random);
}


#############################################################################################################################################################################
#
# query node client, return JSON 
#
sub node_cli {

	use JSON;

	my ($command, $data, $failure) = @_;

	my $response = `$config->{'node_client'} $command $data 2>/dev/null`;		# every time you use backticks a puppy dies :-(

	if (eval { decode_json($response) } ) {						# invalid kills puppys too
		return(decode_json($response));
	}
	else {										# bad response
		if ($failure eq 'abort') {						# 'abort' flag means we shutdown now
			print("Node is down, aborting\n");
			exit(1);
		}
	}
}


#############################################################################################################################################################################
#
# LIBRUSTZCASH : subs that summon librustzcash functions
#
#############################################################################################################################################################################

# Derive incoming viewkey from extended full viewkey
#
# TODO: Should accept *any* flavour of viewkey and return IVK
#
sub xfvk_to_ivk {

	my ($xfvk_str) = @_;

	$xfvk_str = xfvk_check($xfvk_str);						# check length & prefix
	if (!$xfvk_str) {								# 
		return(0);
	}

	my $xfvk = bech32::decode_bech32($xfvk_str);					# extended full viewkey (285 chars)
	my $ak = substr($xfvk, 0,  32);							# ak 
	my $nk = substr($xfvk, 32, 32);							# nk 
	my $ovk = substr($xfvk, 64, 32);						# output view key
	# dk 										# diversifier key
	# c										# chain code

	my $ivk_ret = pack("c32", 0);							# allocate memory for response
	my ($ivk_ptr, $ivk_size) = scalar_to_buffer $ivk_ret;

	librustzcash_crh_ivk ($ak, $nk, $ivk_ptr);					# where the magic happens

	return(unpack("H*", $ivk_ret));							# return ivk as hex string
}


#######################################################################################################################################
#
# Derive payment address from extended full viewkey 
#
sub xfvk_to_addr {

	my ($xfvk_str) = @_;								# bech32 encoded extended full viewkey

	$xfvk_str = xfvk_check($xfvk_str);						# check length & prefix
	if (!$xfvk_str) {								# 
		return(0);
	}
	else {

		my $xfvk = bech32::decode_bech32($xfvk_str);				# full viewkey (285 chars)

		my $j   = pack("c11", 0);						# diversifier (11 bytes);

		my $j_ret    			= pack("c11", 0);			# RETURNED diversifier
		my ($j_ptr, $j_size)		= scalar_to_buffer $j_ret;		#

		my $addr_ret 			= pack("c43", 0);			# RETURNED address
		my ($addr_ptr, $addr_size) 	= scalar_to_buffer $addr_ret;		#

		librustzcash_zip32_xfvk_address( $xfvk, $j, $j_ptr, $addr_ptr);		# where the magic happens

		return(bech32::encode_bech32('zs', $addr_ret));				# return as bech32 encoded string
	}
}


#######################################################################################################################################
#
# Attempt to decode a sapling transaction 
#
sub decrypt_note {

	my ($height, $xfvk, $cmu, $epk, $enc_ciphertext) = @_;				# height (int), hex-encoded strings (all other vars)

	$xfvk = xfvk_check($xfvk);							# check viewkey for length & prefix
	if (!$xfvk) {									# 
		return(0);
	}

	my $value_ret    			= pack("c8", 0);			# allocate memory for returned values
	my ($value_ptr, $value_size)		= scalar_to_buffer $value_ret;		#	
											#
	my $memo_ret    			= pack("c512", 0);			# 
	my ($memo_ptr, $memo_size)		= scalar_to_buffer $memo_ret;		#	

	my $result = librustzcash_xfvk_decrypt_note(					# where the magic happens
		$height,	 								# (u32) 	block height
		pack("A285", $xfvk), 								# (285-bytes)	full viewkey
		pack("H64", $cmu), 								# (32-bytes)	commitment u-coordinate	
		pack("H64", $epk), 								# (32-bytes)	ephemeral key	
		pack("H1160", $enc_ciphertext),							# (580-bytes)	encrypted 

		$value_ptr,									# (8-bytes)	value (u64)
		$memo_ptr									# (512-bytes)	memo (null padded)
	);

	return( {status => $result, addr => $addr_ret, value => $value_ret, memo => $memo_ret} );
}


#######################################################################################################################################
#
# Check Extended Full Viewing Key
#
sub xfvk_check {

	my ($xfvk_str) = @_;				# bech32 encoded extended full viewkey

	$xfvk_str =~ s/\0//g;				# strip null padding
	$xfvk_str =~ s/\s//g;				# strip whitespace

	if (index($xfvk_str, 'zxviews') != 0) {
#		debug("xfvk_to_addr() : full viewkey had the wrong prefix, expected \'zxviews\', received \'$xfvk_str\'");
		return(0);
	}
	elsif (length($xfvk_str) < 285) {			
#		debug("xfvk_to_addr() : full viewkey too short, expected 285 chars, received " . length($xfvk_str) . " bytes" . "\n");
		return(0);
	}

	$xfvk_str = substr($xfvk_str,0,285);		# chop key to correct length
	return($xfvk_str);				# viewing key is valid, return cleaned value
}


#######################################################################################################################################
#
# generate key from a string, input can be a raw ascii string OR hex chars
#
sub keyGen {

	if ($_[0] =~ m/[^0-9a-fA-F]/) {					# string contains non-hex, hash char byte values
		return(sha256(pack("A*", $_[0])));
	}
	else {								# string is hex-encoded, hash byte values
		return(sha256(pack("H*", $_[0])));
	}
}


#######################################################################################################################################
#
# decrypt message
#
sub decryptAES {

	# TODO: Authenticate ciphertext
	
	my ($key, $input) = @_;

	my $inputHEX = unpack("H*", $input);					# convert binary scalar input to hex-encoded string

	$ivHEX  = substr($inputHEX, 0, 32);					# init vector is first 16 bytes, 32 hex chars

	if (length($inputHEX) >= 64) {						# make sure we have more than minimum data, avoids dying horribly

		$cipherHEX = substr($inputHEX, 32, (length($inputHEX) - 32));	# ciphertext, as hex string

		my $cipher = Crypt::CBC->new({ 					# setup encyption
			'key' => $key,
			'cipher' => 'OpenSSL::AES',
			'blocksize' => 16,
			'header' => 'none',
			'iv' => pack("H*", $ivHEX),
			'literal_key' => 1,					
			'padding' => 'standard'
		});

		return($cipher->decrypt(pack("H*", $cipherHEX)));		# result is a binary scalar
	}
}


#######################################################################################################################################
#
# encrypt message								returns binary ciphertext, enrypts binary plaintext
#
sub encryptAES {

	# TODO: Authenticate ciphertext
	
	my ($key, $plaintext) = @_;						# key is a binary scalar, plaintext is a string

	$iv  = pack("H*", keyRandom(32));					# generate random init vector (32 hex chars, packs to 128-bit)

	my $cipher = Crypt::CBC->new({ 						# setup encyption
		'key' => $key,
		'cipher' => 'OpenSSL::AES',
		'blocksize' => 16,
		'header' => 'none',
		'iv' => $iv,
		'literal_key' => 1,				
		'padding' => 'standard'
	});
	my $ciphertext = $cipher->encrypt($plaintext);	

	return($iv . $ciphertext);						# return binary scalar
}


